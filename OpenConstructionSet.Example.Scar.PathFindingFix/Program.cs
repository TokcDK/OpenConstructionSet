using OpenConstructionSet.Data;
using OpenConstructionSet.Installations;
using OpenConstructionSet.Mods;
using OpenConstructionSet.Mods.Context;

const string ModName = "OCSP SCAR's pathfinding fix";
const string ModFileName = ModName + ".mod";
const string ReferenceModName = "SCAR's pathfinding fix.mod";
List<string> excluded = new List<string>()
{
    "OCSP SCAR's pathfinding fix",
    "Bigger Backpacks",
    "-KCF autogenerated patch-",
};

var raceIDMod = new Dictionary<string, int>()
{
    // 2b has human appearance
    {"10-2B.mod",0 },
    {"76-2B.mod",0 }
};

Console.WriteLine("OpenConstructionSet Patcher Example");
Console.WriteLine("SCAR's pathfinding fix https://www.nexusmods.com/kenshi/mods/602");
Console.WriteLine();

IInstallation? installation = await SelectInstallation();

Console.WriteLine();

Console.Write("Reading load order... ");
var baseMods = await ModsToPatch();

Console.WriteLine("done");

Console.Write("Loading data... ");

var (waterAvoidance, pathfindAcceleration, version) = await ReadScarsMod();

var context = await BuildModContext();

Console.WriteLine("done");

// Get all races where editor limits are set i.e. it is not an animal race
var animStrIDs = new List<string>()
{
    //Animations Overhaul Crafting
    "1535098-AnimationOverhaul.mod",
    "1535113-AnimationOverhaul.mod",
    //Great Anims
    "10-Great Anims Mod.mod",
    //More Combat Animations
    "1535143-More Combat Animation.mod",
    //Military craft
    "1535133-Military craft.mod",
};
/// <summary>
/// sound id => List(ReferenceCategory name => List(references))
/// </summary>

var referenceCategoriesRefs = new Dictionary<int, Dictionary<string, HashSet<ModReference>>>();

var races = context.Items.OfType(ItemType.Race);
foreach (var race in races)
{
    // Scar pathfinding fix
    if (race.Values.TryGetValue("editor limits", out var value)
        && value is FileValue file
        && !string.IsNullOrEmpty(file.Path))
    {

        Console.WriteLine("Updating " + race.Name);
        race.Values["pathfind acceleration"] = pathfindAcceleration;

        // avoid changing for races that like water
        if (race.Values.ContainsKey("water avoidance") && (float)race.Values["water avoidance"] > 0)
        {
            race.Values["water avoidance"] = waterAvoidance;
        }
    }

    // Animation mods merge
    if (race.Values.TryGetValue("male mesh", out var meshValue)
        && meshValue is FileValue meshFile
        && !string.IsNullOrEmpty(meshFile.Path)
        && !meshFile.Path.Contains(@"\animal\")
        )
    {
        Console.WriteLine("Updating " + race.Name);
        if (!race.ReferenceCategories.ContainsKey("animation files")) race.ReferenceCategories.Add("animation files");

        var animFiles = race.ReferenceCategories["animation files"];
        foreach (var animRef in animStrIDs)
        {
            if (!animFiles.References.ContainsKey(animRef)) animFiles.References.Add(animRef);
        }


        // hairs beards heads animations GET by sounds value

        if (!race.Values.ContainsKey("sounds")) continue;
        if (race.Values["sounds"] is not int soundsID) continue;
        soundsID = getRaceSoundsID(race, soundsID);
        referenceCategoriesRefs.TryAdd(soundsID, new());
        var parent = referenceCategoriesRefs[soundsID];

        foreach (var propertyName in new[] { "hair colors", "hairs"/*, "heads female", "heads male"*/, "animation files" })
        {
            if (!race.ReferenceCategories.ContainsKey(propertyName)) continue;

            parent.TryAdd(propertyName, new());

            var propCat = parent[propertyName];
            var propRefs = race.ReferenceCategories[propertyName].References;
            foreach (var propref in propRefs)
            {
                if (!propCat.Contains(propref)) propCat.Add(propref);
            }
        }
    }
}

// hairs beards heads animations ADD by sounds value
foreach (var race in races)
{
    if (!race.Values.ContainsKey("sounds")) continue;
    if (race.Values["sounds"] is not int soundsID) continue;
    soundsID = getRaceSoundsID(race, soundsID);
    if (!referenceCategoriesRefs.ContainsKey(soundsID)) continue;

    var itemsBySoundsID = referenceCategoriesRefs[soundsID];
    foreach (var categoryReferences in itemsBySoundsID)
    {
        if (!race.ReferenceCategories.ContainsKey(categoryReferences.Key)) race.ReferenceCategories.Add(categoryReferences.Key);

        var refList = race.ReferenceCategories[categoryReferences.Key].References;
        foreach (var reference in categoryReferences.Value)
        {
            if (!IsValidToAdd(race, reference, categoryReferences.Key) || refList.ContainsKey(reference.TargetId)) continue;

            refList.Add(reference.TargetId, GetVal0(race, categoryReferences.Key), GetVal1(race, categoryReferences.Key), GetVal2(race, categoryReferences.Key));
        }
    }
}

//var listOfLimbs = new List<ModReference>();// string ids
//var addedLimbs = new HashSet<string>();// string ids
//// add limbs from chars
//foreach (var character in context.Items.OfType(ItemType.Character))
//{
//    if (!character.Values.ContainsKey("unique")) continue;
//    if (character.Values["unique"] is not bool unique || unique) continue;
//    if (!character.ReferenceCategories.ContainsKey("robot limbs")) continue;

//    foreach (var reference in character.ReferenceCategories["robot limbs"].References)
//    {
//        if (addedLimbs.Contains(reference.TargetId)) continue;

//        addedLimbs.Add(reference.TargetId);
//        listOfLimbs.Add(reference);
//    }
//}
//foreach (var character in context.Items.OfType(ItemType.Character))
//{
//    if (!character.Values.ContainsKey("unique")) continue;
//    if (character.Values["unique"] is not bool unique || unique) continue;
//    //if (!character.ReferenceCategories.ContainsKey("robot limbs")) continue;

//    if (character.Values["armour grade"] is not int s) continue;

//    int limbQuality = 0;
//    if (s == 0)//"GEAR_PROTOTYPE"
//    {
//    }
//    else if (s == 1)//"GEAR_CHEAP"
//    {
//        limbQuality = 20;
//    }
//    else if (s == 2)//"GEAR_STANDARD"
//    {
//        limbQuality = 40;
//    }
//    else if (s == 3)//"GEAR_GOOD"
//    {
//        limbQuality = 60;
//    }
//    else if (s == 4)//"GEAR_QUALITY"
//    {
//        limbQuality = 80;
//    }
//    else if (s == 5)//"GEAR_MASTER"
//    {
//        limbQuality = 100;
//    }

//    float charCombat = (character.Values["combat stats"] is int cc ? cc : 0);
//    float charRanged = (character.Values["ranged stats"] is int cr ? cr : 0);
//    float charStealth = (character.Values["stealth stats"] is int cs ? cs : 0);


//    if (!character.ReferenceCategories.ContainsKey("robot limbs")) character.ReferenceCategories.Add("robot limbs");
//    var categoryReferences = character.ReferenceCategories["robot limbs"].References;
//    foreach (var limb in listOfLimbs)
//    {
//        if (categoryReferences.ContainsKey(limb.TargetId)) continue;

//        float limbdex1 = (limb.Target!.Values["dexterity mult"] is float ldf ? ldf : 0);
//        float limbdex2 = (limb.Target!.Values["dexterity mult 1"] is float ldf1 ? ldf1 : 0);
//        float limbDex = (limbdex1 + limbdex2) / 2;

//        float limbranged1 = (limb.Target!.Values["ranged mult"] is float lrf ? lrf : 0);
//        float limbranged2 = (limb.Target!.Values["ranged mult 1"] is float lrf1 ? lrf1 : 0);
//        float limbRanged = (limbranged1 + limbranged2) / 2;

//        float limbstr1 = (limb.Target!.Values["strength mult"] is float lsf ? lsf : 0);
//        float limbstr2 = (limb.Target!.Values["strength mult 1"] is float lsf1 ? lsf1 : 0);
//        float limbStr = (limbstr1 + limbstr2) / 2;

//        float limbthie1 = (limb.Target!.Values["thievery mult"] is float ltf ? ltf : 0);
//        float limbthie2 = (limb.Target!.Values["thievery mult 1"] is float ltf1 ? ltf1 : 0);
//        float limbThie = (limbthie1 + limbthie2) / 2;

//        float limbstealth1 = (limb.Target!.Values["stealth mult"] is float lstealthf ? lstealthf : 0);
//        float limbstealth2 = (limb.Target!.Values["stealth mult 1"] is float lstealthf1 ? lstealthf1 : 0);
//        float limbstealth = (limbstealth1 + limbstealth2) / 2;

//        float limbathletics1 = (limb.Target!.Values["athletics mult"] is float lathleticsf ? lathleticsf : 0);
//        float limbathletics2 = (limb.Target!.Values["athletics mult 1"] is float lathleticsf1 ? lathleticsf1 : 0);
//        float limbathletics = (limbstealth1 + limbstealth2) / 2;

//        var limbCombatResult = (limbDex + limbStr + limbathletics) / 3;
//        var limbRangedResult = (limbDex + limbRanged + limbathletics) / 3;
//        var limbStealthResult = (limbDex + limbThie + limbstealth) / 3;

//        int relativeCombat = (int)(charCombat * limbCombatResult);
//        int relativeRanged = (int)(charRanged * limbRangedResult);
//        int relativeStealth = (int)(charStealth * limbStealthResult);

//        var limbRelativeChance = Math.Max(Math.Max(relativeCombat, relativeRanged), relativeStealth)/10;

//        categoryReferences.Add(limb.TargetId, limbQuality, limbRelativeChance);
//    }
//}

// crossbows distribute
//var ItemsToDistributeList = new List<ModReference>();// string ids
//var addedItemsList = new HashSet<string>();// string ids
//// add limbs from chars
//foreach (var character in context.Items.OfType(ItemType.Character))
//{
//    if (!character.ReferenceCategories.ContainsKey("crossbows")) continue;

//    foreach (var reference in character.ReferenceCategories["crossbows"].References)
//    {
//        if (addedItemsList.Contains(reference.TargetId)) continue;

//        addedItemsList.Add(reference.TargetId);
//        ItemsToDistributeList.Add(reference);
//    }
//}
//foreach (var character in context.Items.OfType(ItemType.Character))
//{
//    //if (!character.ReferenceCategories.ContainsKey("robot limbs")) continue;

//    if (character.Values["armour grade"] is not int s) continue;

//    int limbQuality = 0;
//    if (s == 0)//"GEAR_PROTOTYPE"
//    {
//    }
//    else if (s == 1)//"GEAR_CHEAP"
//    {
//        limbQuality = 20;
//    }
//    else if (s == 2)//"GEAR_STANDARD"
//    {
//        limbQuality = 40;
//    }
//    else if (s == 3)//"GEAR_GOOD"
//    {
//        limbQuality = 60;
//    }
//    else if (s == 4)//"GEAR_QUALITY"
//    {
//        limbQuality = 80;
//    }
//    else if (s == 5)//"GEAR_MASTER"
//    {
//        limbQuality = 100;
//    }

//    float charCombat = (character.Values["combat stats"] is int cc ? cc : 0);
//    float charRanged = (character.Values["ranged stats"] is int cr ? cr : 0);
//    float charStealth = (character.Values["stealth stats"] is int cs ? cs : 0);


//    if (!character.ReferenceCategories.ContainsKey("robot limbs")) character.ReferenceCategories.Add("robot limbs");
//    var categoryReferences = character.ReferenceCategories["robot limbs"].References;
//    foreach (var limb in ItemsToDistributeList)
//    {
//        if (categoryReferences.ContainsKey(limb.TargetId)) continue;

//        float limbdex1 = (limb.Target!.Values["dexterity mult"] is float ldf ? ldf : 0);
//        float limbdex2 = (limb.Target!.Values["dexterity mult 1"] is float ldf1 ? ldf1 : 0);
//        float limbDex = (limbdex1 + limbdex2) / 2;

//        float limbranged1 = (limb.Target!.Values["ranged mult"] is float lrf ? lrf : 0);
//        float limbranged2 = (limb.Target!.Values["ranged mult 1"] is float lrf1 ? lrf1 : 0);
//        float limbRanged = (limbranged1 + limbranged2) / 2;

//        float limbstr1 = (limb.Target!.Values["strength mult"] is float lsf ? lsf : 0);
//        float limbstr2 = (limb.Target!.Values["strength mult 1"] is float lsf1 ? lsf1 : 0);
//        float limbStr = (limbstr1 + limbstr2) / 2;

//        float limbthie1 = (limb.Target!.Values["thievery mult"] is float ltf ? ltf : 0);
//        float limbthie2 = (limb.Target!.Values["thievery mult 1"] is float ltf1 ? ltf1 : 0);
//        float limbThie = (limbthie1 + limbthie2) / 2;

//        float limbstealth1 = (limb.Target!.Values["stealth mult"] is float lstealthf ? lstealthf : 0);
//        float limbstealth2 = (limb.Target!.Values["stealth mult 1"] is float lstealthf1 ? lstealthf1 : 0);
//        float limbstealth = (limbstealth1 + limbstealth2) / 2;

//        float limbathletics1 = (limb.Target!.Values["athletics mult"] is float lathleticsf ? lathleticsf : 0);
//        float limbathletics2 = (limb.Target!.Values["athletics mult 1"] is float lathleticsf1 ? lathleticsf1 : 0);
//        float limbathletics = (limbstealth1 + limbstealth2) / 2;

//        var limbCombatResult = (limbDex + limbStr + limbathletics) / 3;
//        var limbRangedResult = (limbDex + limbRanged + limbathletics) / 3;
//        var limbStealthResult = (limbDex + limbThie + limbstealth) / 3;

//        int relativeCombat = (int)(charCombat * limbCombatResult);
//        int relativeRanged = (int)(charRanged * limbRangedResult);
//        int relativeStealth = (int)(charStealth * limbStealthResult);

//        var limbRelativeChance = Math.Max(Math.Max(relativeCombat, relativeRanged), relativeStealth) / 10;

//        categoryReferences.Add(limb.TargetId, limbQuality, limbRelativeChance);
//    }
//}


bool IsValidToAdd(ModItem race, ModReference reference, string categoryName)
{
    //if (categoryName == "robot limbs" && race.Values.ContainsKey("unique") && race.Values["unique"] is bool b && b)
    //{
    //    return false;
    //}

    return true;
}

int GetVal2(ModItem race, string categoryName)
{
    if (categoryName == "robot limbs")
    {
    }

    return 0;
}

int GetVal1(ModItem race, string categoryName)
{
    return 0;
}

int GetVal0(ModItem race, string categoryName)
{
    return 0;
}

// Stackable items 1000
var items = context.Items.OfType(ItemType.Item);
foreach (var item in items)
{
    if (!item.Values.TryGetValue("stackable", out var value)) continue;
    if (!item.Values.TryGetValue("slot", out var slotValue)) continue;
    if (slotValue is not int i || i != 7) continue; // attach slot none
    if (value is not int v || v >= 1000) continue; // already max

    Console.WriteLine("Updating " + item.Name);
    item.Values["stackable"] = 1000;
}

// Bigger backpacks
var backpacks = context.Items.OfType(ItemType.Container).ToArray();
HashSet<string> changed = new();
foreach (var item in backpacks)
{
    if (item.Name.StartsWith("@") || item.Name.StartsWith("_")) continue;
    if (!item.Values.TryGetValue("slot", out var value)) continue;
    if (value is not int v || v != 12) continue; // backpack
    if (changed.Contains(item.StringId)) continue; // backpack

    Console.WriteLine("Updating " + item.Name);

    //var cskill = (int)item.Values["combat skill bonus"];
    //item.Values["combat skill bonus"] = (cskill += 10);
    //if (cskill > 0) item.Values["combat skill bonus"] = (int)(cskill+1) / 2;

    //var cspeed = (float)item.Values["combat speed mult"];
    //item.Values["combat speed mult"] = (cspeed = ((float)(cspeed + 0.5)));
    //if (cspeed > 1) item.Values["combat speed mult"] = (float)(1.0 + ((cspeed - 1.0) / 3));

    // reset skill mods
    //item.Values["combat skill bonus"] = 0;
    //item.Values["combat speed mult"] = (float)1.0;
    //item.Values["stealth mult"] = (float)1.0;

    var height = (int)item.Values["storage size height"];
    var width = (int)item.Values["storage size width"];

    changed.Add(item.StringId);

    if (width < 8)
    {
        if (width == height)
        {
            if (width == 3)
            {
                SetBackpackSquareSizeTo(5, item);
            }
            else if (width == 4)
            {
                SetBackpackSquareSizeTo(6, item);
            }
            else if (width == 5)
            {
                SetBackpackSquareSizeTo(7, item);
            }
            else if (width == 6)
            {
                SetBackpackSquareSizeTo(8, item);
            }
        }
    }
    else if (width == 8)
    {
        SetBackpackSquareSizeTo(12, item);
    }
    else if (width == 10)
    {
        SetBackpackSquareSizeTo(16, item);
    }
    else if (width == 12)
    {
        ResizeWidthToHeightOr(item, width, height, 20);
    }
    else if (width > 30)
    {
        // do nothing
    }
    else if (width > 20)
    {
        ResizeWidthToHeightOr(item, width, height, 30);
    }
    else if (width > 12)
    {
        ResizeWidthToHeightOr(item, width, height, 24);
    }
}

void SetBackpackSquareSizeTo(int size, ModItem item)
{
    item.Values["storage size height"] = size;
    item.Values["storage size width"] = size;
}

void ResizeWidthToHeightOr(ModItem item, int width, int height, int size)
{
    if (width < height)
    {
        item.Values["storage size width"] = height;
    }
    else
    {
        SetBackpackSquareSizeTo(size, item);
    }
}

Console.Write("Saving... ");

await context.SaveAsync();

Console.WriteLine("done");

Console.Write("Adding patch to end of load order... ");

var enabledMods = (await installation!.ReadEnabledModsAsync()).ToList();

// Remove this mod and then add to the end of the load order
enabledMods.RemoveAll(s => s == ModFileName);
enabledMods.Add(ModFileName);

await installation.WriteEnabledModsAsync(enabledMods);

Console.WriteLine("done");
Console.ReadKey();

/// <summary>
/// some races like in 2b mod using human appearance attachments
/// </summary>
int getRaceSoundsID(ModItem race, int inputSoundsID)
{
    if (raceIDMod!.ContainsKey(race.StringId)) return raceIDMod[race.StringId];

    return inputSoundsID;
}

async Task<IInstallation?> SelectInstallation()
{
    var installations = await new InstallationService().DiscoverAllInstallationsAsync().ToDictionaryAsync(i => i.Identifier);

    if (installations.Count == 0)
    {
        Error("Unable to find game");
        return null;
    }
    else if (installations.Count == 1)
    {
        // One installation so use it
        return installations.Values.First();
    }
    else
    {
        // Display the installations to the user
        var keys = installations.Keys.ToList();

        Console.WriteLine("Multiple installations found");

        for (var i = 0; i < keys.Count; i++)
        {
            Console.WriteLine($"{i + 1} - {keys[i]}");
        }

        Console.Write("Please select which to use: ");

        // Get the user to chose
        var selection = keys[int.Parse(Console.ReadLine() ?? "1") - 1];

        Console.WriteLine($"Using the {selection} installation");

        return installations[selection];
    }
}

void Error(string message)
{
    Console.WriteLine(message);
    Console.ReadKey();
    Environment.Exit(1);
}

async Task<(float waterAvoidance, float pathFindAcceleration, int version)> ReadScarsMod()
{
    if (!installation!.Mods.TryFind(ReferenceModName, out var referenceMod))
    {
        // Not found
        Error($"Unable to find {ReferenceModName}");
        return (0, 0, 0);
    }

    ModFileData referenceData;

    try
    {
        referenceData = await referenceMod.ReadDataAsync();
    }
    catch (Exception ex)
    {
        Error($"Unable to load {ReferenceModName}{Environment.NewLine}Error: {ex}");
        return (0, 0, 0);
    }

    // Extract core values from the Greenlander race item
    var greenlander = referenceData.Items.Find(i => i.Name == "Greenlander");

    if (greenlander is null)
    {
        Error("Could not find Greenlander");
        return (0, 0, 0);
    }

    var pathfindAcceleration = greenlander.Values["pathfind acceleration"];
    var waterAvoidance = greenlander.Values["water avoidance"];

    return ((float)waterAvoidance, (float)pathfindAcceleration, referenceData.Header.Version);
}

async Task<IModContext> BuildModContext()
{
    // Build mod
    var header = new Header(version,
                            "LMayDev",
                            "OpenConstructionSet Compatibility patch to apply core values from SCAR's pathfinding fix to custom races");
    header.References.Add(ReferenceModName);
    header.Dependencies.AddRange(baseMods);

    var options = new ModContextOptions(ModFileName,
        installation: installation!,
        baseMods: baseMods,
        header: header,
        loadGameFiles: ModLoadType.Base,
        //loadEnabledMods: ModLoadType.Active,
        throwIfMissing: false);

    return await new ContextBuilder().BuildAsync(options);
}

async Task<List<string>> ModsToPatch()
{
    var mods = new List<string>(await installation!.ReadEnabledModsAsync());

    // Don't patch ourselves or SCAR's mod
    mods.Remove(ModFileName);
    mods.Remove(ReferenceModName);
    foreach (var name in excluded) mods.Remove(name + ".mod");

    if (mods.Count == 0)
    {
        // No mods found to patch
        Error($"failed!{Environment.NewLine}No mods found to patch");
        return new();
    }

    return mods;
}