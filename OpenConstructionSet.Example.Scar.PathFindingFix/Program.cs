using OpenConstructionSet.Data;
using OpenConstructionSet.Installations;
using OpenConstructionSet.Mods;
using OpenConstructionSet.Mods.Context;

const string ModName = "OCSP SCAR's pathfinding fix";
const string ModFileName = ModName + ".mod";
const string ReferenceModName = "SCAR's pathfinding fix.mod";
List<string> Excluded = new List<string>()
{
    "overall patch",
    "OCSP SCAR's pathfinding fix",
    "Bigger Backpacks",
    "-KCF autogenerated patch-",
};

Console.WriteLine("OpenConstructionSet Patcher Example");
Console.WriteLine("SCAR's pathfinding fix https://www.nexusmods.com/kenshi/mods/602");
Console.WriteLine();

IInstallation? installation = await SelectInstallation();

Console.WriteLine();

Console.Write("Reading load order... ");
var baseMods = await ModsToPatch();

Console.WriteLine("done");

Console.Write("Loading data... ");

var (waterAvoidance, pathfindAcceleration, version) = await ReadScarsMod();

var context = await BuildModContext();

Console.WriteLine("done");

// Get all races where editor limits are set i.e. it is not an animal race
var AnimStrIDs = new List<string>()
{
    //Animations Overhaul Crafting
    "1535098-AnimationOverhaul.mod",
    "1535113-AnimationOverhaul.mod",
    //Great Anims
    "10-Great Anims Mod.mod",
    //More Combat Animations
    "1535143-More Combat Animation.mod",
    //Military craft
    "1535133-Military craft.mod",
};

var itemsAttachments = new Dictionary<int, Dictionary<string, HashSet<ModReference>>>();

var races = context.Items.OfType(ItemType.Race);
foreach (var race in races)
{
    // Scar pathfinding fix
    if (race.Values.TryGetValue("editor limits", out var value)
        && value is FileValue file
        && !string.IsNullOrEmpty(file.Path))
    {

        Console.WriteLine("Updating " + race.Name);
        race.Values["pathfind acceleration"] = pathfindAcceleration;

        // avoid changing for races that like water
        if (race.Values.ContainsKey("water avoidance") && (float)race.Values["water avoidance"] > 0)
        {
            race.Values["water avoidance"] = waterAvoidance;
        }
    }

    // Animation mods merge
    if (race.Values.TryGetValue("male mesh", out var meshValue)
        && meshValue is FileValue meshFile
        && !string.IsNullOrEmpty(meshFile.Path)
        && !meshFile.Path.Contains(@"\animal\")
        )
    {
        Console.WriteLine("Updating " + race.Name);
        if (!race.ReferenceCategories.ContainsKey("animation files")) race.ReferenceCategories.Add("animation files");

        var AnimFiles = race.ReferenceCategories["animation files"];
        foreach (var animRef in AnimStrIDs)
        {
            if (!AnimFiles.References.ContainsKey(animRef)) AnimFiles.References.Add(animRef);
        }


        // hairs beards heads animations GET by sounds value

        if (!race.Values.ContainsKey("sounds")) continue;
        if (race.Values["sounds"] is not int sounds) continue;
        itemsAttachments.TryAdd(sounds, new());
        var parent = itemsAttachments[sounds];

        foreach (var propertyName in new[] { "hair colors", "hairs", "heads female", "heads male", "animation files" })
        {
            if (!race.ReferenceCategories.ContainsKey(propertyName)) continue;

            parent.TryAdd(propertyName, new());

            var propCat = parent[propertyName];
            var propRefs = race.ReferenceCategories[propertyName].References;
            foreach (var propref in propRefs)
            {
                if (!propCat.Contains(propref)) propCat.Add(propref);
            }
        }
    }
}

// hairs beards heads animations ADD by sounds value
foreach (var race in races)
{
    if (!race.Values.ContainsKey("sounds")) continue;
    if (race.Values["sounds"] is not int sounds) continue;
    if (!itemsAttachments.ContainsKey(sounds)) continue;

    var parent = itemsAttachments[sounds];
    foreach (var prop in parent)
    {
        if (!race.ReferenceCategories.ContainsKey(prop.Key)) race.ReferenceCategories.Add(prop.Key);

        var refList = race.ReferenceCategories[prop.Key].References;
        foreach (var propRef in prop.Value)
        {
            if (!refList.ContainsKey(propRef.Target!.StringId)) refList.Add(propRef.Target!.StringId);
        }
    }
}

// Stackable items 1000
var items = context.Items.OfType(ItemType.Item);
foreach (var item in items)
{
    if (!item.Values.TryGetValue("stackable", out var value)) continue;
    if (!item.Values.TryGetValue("slot", out var slotValue)) continue;
    if (slotValue is not int i || i != 7) continue; // attach slot none
    if (value is not int v || v >= 1000) continue; // already max

    Console.WriteLine("Updating " + item.Name);
    item.Values["stackable"] = 1000;
}

// Bigger backpacks
var backpacks = context.Items.OfType(ItemType.Container);
HashSet<string> changed = new();
foreach (var item in backpacks)
{
    if (item.Name.StartsWith("@") || item.Name.StartsWith("_")) continue;
    if (!item.Values.TryGetValue("slot", out var value)) continue;
    if (value is not int v || v != 12) continue; // backpack
    if (changed.Contains(item.StringId)) continue; // backpack

    Console.WriteLine("Updating " + item.Name);

    //var cskill = (int)item.Values["combat skill bonus"];
    //item.Values["combat skill bonus"] = (cskill += 10);
    //if (cskill > 0) item.Values["combat skill bonus"] = (int)(cskill+1) / 2;

    //var cspeed = (float)item.Values["combat speed mult"];
    //item.Values["combat speed mult"] = (cspeed = ((float)(cspeed + 0.5)));
    //if (cspeed > 1) item.Values["combat speed mult"] = (float)(1.0 + ((cspeed - 1.0) / 3));

    //item.Values["stealth mult"] = 1;

    item.Values["combat skill bonus"] = 0;
    item.Values["combat speed mult"] = (float)1.0;

    var height = (int)item.Values["storage size height"];
    var width = (int)item.Values["storage size width"];

    changed.Add(item.StringId);

    if (width < 8)
    {
        if (width == height)
        {
            if (width == 3)
            {
                item.Values["storage size height"] = 5;
                item.Values["storage size width"] = 5;
            }
            else if (width == 4)
            {
                item.Values["storage size height"] = 6;
                item.Values["storage size width"] = 6;
            }
            else if (width == 5)
            {
                item.Values["storage size height"] = 7;
                item.Values["storage size width"] = 7;
            }
            else if (width == 6)
            {
                item.Values["storage size height"] = 8;
                item.Values["storage size width"] = 8;
            }
        }
    }
    else if (width == 8)
    {
        item.Values["storage size height"] = 12;
        item.Values["storage size width"] = 12;
    }
    else if (width == 10)
    {
        item.Values["storage size height"] = 16;
        item.Values["storage size width"] = 16;
    }
    else if (width == 12)
    {
        if (width < height)
        {
            item.Values["storage size width"] = item.Values["storage size height"];
        }
        else
        {
            item.Values["storage size width"] = 20;
            item.Values["storage size height"] = 20;
        }
    }
    else if (width > 30)
    {
        // do nothing
    }
    else if (width > 20)
    {
        if (width < height)
        {
            item.Values["storage size width"] = item.Values["storage size height"];
        }
        else
        {
            item.Values["storage size width"] = 30;
            item.Values["storage size height"] = 30;
        }
    }
    else if (width > 12)
    {
        if (width < height)
        {
            item.Values["storage size width"] = item.Values["storage size height"];
        }
        else
        {
            item.Values["storage size width"] = 24;
            item.Values["storage size height"] = 24;
        }
    }

}

Console.Write("Saving... ");

await context.SaveAsync();

Console.WriteLine("done");

Console.Write("Adding patch to end of load order... ");

var enabledMods = (await installation!.ReadEnabledModsAsync()).ToList();

// Remove this mod and then add to the end of the load order
enabledMods.RemoveAll(s => s == ModFileName);
enabledMods.Add(ModFileName);

await installation.WriteEnabledModsAsync(enabledMods);

Console.WriteLine("done");
Console.ReadKey();

async Task<IInstallation?> SelectInstallation()
{
    var installations = await new InstallationService().DiscoverAllInstallationsAsync().ToDictionaryAsync(i => i.Identifier);

    if (installations.Count == 0)
    {
        Error("Unable to find game");
        return null;
    }
    else if (installations.Count == 1)
    {
        // One installation so use it
        return installations.Values.First();
    }
    else
    {
        // Display the installations to the user
        var keys = installations.Keys.ToList();

        Console.WriteLine("Multiple installations found");

        for (var i = 0; i < keys.Count; i++)
        {
            Console.WriteLine($"{i + 1} - {keys[i]}");
        }

        Console.Write("Please select which to use: ");

        // Get the user to chose
        var selection = keys[int.Parse(Console.ReadLine() ?? "1") - 1];

        Console.WriteLine($"Using the {selection} installation");

        return installations[selection];
    }
}

void Error(string message)
{
    Console.WriteLine(message);
    Console.ReadKey();
    Environment.Exit(1);
}

async Task<(float waterAvoidance, float pathFindAcceleration, int version)> ReadScarsMod()
{
    if (!installation!.Mods.TryFind(ReferenceModName, out var referenceMod))
    {
        // Not found
        Error($"Unable to find {ReferenceModName}");
        return (0, 0, 0);
    }

    ModFileData referenceData;

    try
    {
        referenceData = await referenceMod.ReadDataAsync();
    }
    catch (Exception ex)
    {
        Error($"Unable to load {ReferenceModName}{Environment.NewLine}Error: {ex}");
        return (0, 0, 0);
    }

    // Extract core values from the Greenlander race item
    var greenlander = referenceData.Items.Find(i => i.Name == "Greenlander");

    if (greenlander is null)
    {
        Error("Could not find Greenlander");
        return (0, 0, 0);
    }

    var pathfindAcceleration = greenlander.Values["pathfind acceleration"];
    var waterAvoidance = greenlander.Values["water avoidance"];

    return ((float)waterAvoidance, (float)pathfindAcceleration, referenceData.Header.Version);
}

async Task<IModContext> BuildModContext()
{
    // Build mod
    var header = new Header(version,
                            "LMayDev",
                            "OpenConstructionSet Compatibility patch to apply core values from SCAR's pathfinding fix to custom races");
    header.References.Add(ReferenceModName);
    header.Dependencies.AddRange(baseMods);

    var options = new ModContextOptions(ModFileName,
        installation: installation!,
        baseMods: baseMods,
        header: header,
        loadGameFiles: ModLoadType.Base,
        //loadEnabledMods: ModLoadType.Active,
        throwIfMissing: false);

    return await new ContextBuilder().BuildAsync(options);
}

async Task<List<string>> ModsToPatch()
{
    var mods = new List<string>(await installation!.ReadEnabledModsAsync());

    // Don't patch ourselves or SCAR's mod
    mods.Remove(ModFileName);
    mods.Remove(ReferenceModName);
    foreach (var name in Excluded) mods.Remove(name + ".mod");

    if (mods.Count == 0)
    {
        // No mods found to patch
        Error($"failed!{Environment.NewLine}No mods found to patch");
        return new();
    }

    return mods;
}